"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _excluded = ["h", "v", "r", "dur", "q", "tf", "int", "max", "orig", "fixed", "freez", "active", "trigger", "fixedStop", "elem"];

var _templateObject, _templateObject2;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var toString = function toString(obj) {
  return Object.keys(obj).reduce(function (acc, next) {
    return "".concat(acc, "\n\t\t\t").concat(next, " {\n\t\t\t\ttransform: ").concat(obj[next].transform, "\n\t\t\t}");
  }, '');
};

var ShakeComp = _styledComponents["default"].div(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  animation-name: ", ";\n  animation-duration: ", "ms;\n  animation-iteration-count: ", ";\n  display: 'inline-block';\n  transform-origin: ", ";\n\n  &", " {\n    animation-name: ", ";\n    animation-play-state: ", ";\n    animation: ", ";\n  }\n\n  animation-play-state: ", ";\n"])), function (p) {
  return p.shouldShakeDefault && p.shakeKeyframes;
}, function (p) {
  return p.dur;
}, function (p) {
  return p.q;
}, function (p) {
  return p.orig;
}, function (p) {
  return p.trigger;
}, function (p) {
  return p.shouldShakeWhenTriggered && p.shakeKeyframes;
}, function (p) {
  return p.freez && (!p.fixed ? 'running' : 'paused');
}, function (p) {
  return p.fixed && p.fixedStop && 'initial';
}, function (p) {
  return p.active ? p.freez && !p.fixed ? 'paused' : 'running' : 'paused';
});

var random = function random(max) {
  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return Math.random() * (max - min) - max / 2;
};

var doKeyframes = function doKeyframes(_int, max, h, v, r) {
  var init = 'translate(0,0) rotate(0)'; // el objecto que iremos llenando

  var kf = {
    '0%': {
      transform: init
    }
  }; // loop con intervalos basados en `int`

  for (var st = _int; st <= max; st += _int) {
    // Numeros aleatorios en cada keyframe
    var x = random(h);
    var y = random(v);
    var rot = random(r);
    kf["".concat(st, "%")] = {
      transform: "translate(".concat(x, "px, ").concat(y, "px) rotate(").concat(rot, "deg)")
    };
  } // Init de las transformaciones en 0% y 100%


  kf["".concat(Math.min(max, 100), "%")] = {
    transform: init
  };
  return toString(kf);
};

var Shake = function Shake(_ref) {
  var _ref$h = _ref.h,
      h = _ref$h === void 0 ? 5 : _ref$h,
      _ref$v = _ref.v,
      v = _ref$v === void 0 ? 5 : _ref$v,
      _ref$r = _ref.r,
      r = _ref$r === void 0 ? 3 : _ref$r,
      _ref$dur = _ref.dur,
      dur = _ref$dur === void 0 ? 300 : _ref$dur,
      _ref$q = _ref.q,
      q = _ref$q === void 0 ? 'infinite' : _ref$q,
      _ref$tf = _ref.tf,
      tf = _ref$tf === void 0 ? 'ease-in-out' : _ref$tf,
      _ref$int = _ref["int"],
      _int2 = _ref$int === void 0 ? 10 : _ref$int,
      _ref$max = _ref.max,
      max = _ref$max === void 0 ? 100 : _ref$max,
      _ref$orig = _ref.orig,
      orig = _ref$orig === void 0 ? 'center center' : _ref$orig,
      _ref$fixed = _ref.fixed,
      fixed = _ref$fixed === void 0 ? false : _ref$fixed,
      _ref$freez = _ref.freez,
      freez = _ref$freez === void 0 ? false : _ref$freez,
      _ref$active = _ref.active,
      active = _ref$active === void 0 ? true : _ref$active,
      _ref$trigger = _ref.trigger,
      trigger = _ref$trigger === void 0 ? ':hover' : _ref$trigger,
      _ref$fixedStop = _ref.fixedStop,
      fixedStop = _ref$fixedStop === void 0 ? false : _ref$fixedStop,
      _ref$elem = _ref.elem,
      elem = _ref$elem === void 0 ? 'div' : _ref$elem,
      props = _objectWithoutProperties(_ref, _excluded);

  // Creamos los `@keyframes`
  var shakeKeyframes = (0, _react.useMemo)(function () {
    return (0, _styledComponents.keyframes)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["", ""])), doKeyframes(_int2, max, h, v, r));
  }, [_int2, max, h, v, r]);
  var shouldShakeDefault = fixed || !fixed && freez;
  var shouldShakeWhenTriggered = !fixed && !freez;
  return /*#__PURE__*/_react["default"].createElement(ShakeComp, _extends({
    as: elem,
    dur: dur,
    orig: orig,
    q: q,
    freez: freez,
    fixed: fixed,
    fixedStop: fixedStop,
    active: active,
    trigger: trigger,
    shakeKeyframes: shakeKeyframes,
    shouldShakeDefault: shouldShakeDefault,
    shouldShakeWhenTriggered: shouldShakeWhenTriggered
  }, props), props.children);
};

var _default = Shake;
exports["default"] = _default;