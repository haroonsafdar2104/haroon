{"ast":null,"code":"import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { animateVisualElement } from './animation.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { AnimationType } from './types.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nconst variantPriorityOrder = [AnimationType.Animate, AnimationType.InView, AnimationType.Focus, AnimationType.Hover, AnimationType.Tap, AnimationType.Drag, AnimationType.Exit];\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\n\nfunction animateList(visualElement) {\n  return animations => Promise.all(animations.map(_ref => {\n    let {\n      animation,\n      options\n    } = _ref;\n    return animateVisualElement(visualElement, animation, options);\n  }));\n}\n\nfunction createAnimationState(visualElement) {\n  let animate = animateList(visualElement);\n  const state = createState();\n  let isInitialRender = true;\n  /**\n   * This function will be used to reduce the animation definitions for\n   * each active animation type into an object of resolved values for it.\n   */\n\n  const buildResolvedTypeValues = (acc, definition) => {\n    const resolved = resolveVariant(visualElement, definition);\n\n    if (resolved) {\n      const {\n        transition,\n        transitionEnd,\n        ...target\n      } = resolved;\n      acc = { ...acc,\n        ...target,\n        ...transitionEnd\n      };\n    }\n\n    return acc;\n  };\n  /**\n   * This just allows us to inject mocked animation functions\n   * @internal\n   */\n\n\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\n   * When we receive new props, we need to:\n   * 1. Create a list of protected keys for each type. This is a directory of\n   *    value keys that are currently being \"handled\" by types of a higher priority\n   *    so that whenever an animation is played of a given type, these values are\n   *    protected from being animated.\n   * 2. Determine if an animation type needs animating.\n   * 3. Determine if any values have been removed from a type and figure out\n   *    what to animate those to.\n   */\n\n\n  function animateChanges(options, changedActiveType) {\n    var _a;\n\n    const props = visualElement.getProps();\n    const context = visualElement.getVariantContext(true) || {};\n    /**\n     * A list of animations that we'll build into as we iterate through the animation\n     * types. This will get executed at the end of the function.\n     */\n\n    const animations = [];\n    /**\n     * Keep track of which values have been removed. Then, as we hit lower priority\n     * animation types, we can check if they contain removed values and animate to that.\n     */\n\n    const removedKeys = new Set();\n    /**\n     * A dictionary of all encountered keys. This is an object to let us build into and\n     * copy it without iteration. Each time we hit an animation type we set its protected\n     * keys - the keys its not allowed to animate - to the latest version of this object.\n     */\n\n    let encounteredKeys = {};\n    /**\n     * If a variant has been removed at a given index, and this component is controlling\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\n     */\n\n    let removedVariantIndex = Infinity;\n    /**\n     * Iterate through all animation types in reverse priority order. For each, we want to\n     * detect which values it's handling and whether or not they've changed (and therefore\n     * need to be animated). If any values have been removed, we want to detect those in\n     * lower priority props and flag for animation.\n     */\n\n    for (let i = 0; i < numAnimationTypes; i++) {\n      const type = reversePriorityOrder[i];\n      const typeState = state[type];\n      const prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      const propIsVariant = isVariantLabel(prop);\n      /**\n       * If this type has *just* changed isActive status, set activeDelta\n       * to that status. Otherwise set to null.\n       */\n\n      const activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\n       * If this prop is an inherited variant, rather than been set directly on the\n       * component itself, we want to make sure we allow the parent to trigger animations.\n       *\n       * TODO: Can probably change this to a !isControllingVariants check\n       */\n\n      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      /**\n       *\n       */\n\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\n       * Set all encountered keys so far as the protected keys for this type. This will\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n       */\n\n\n      typeState.protectedKeys = { ...encounteredKeys\n      }; // Check if we can skip analysing this prop early\n\n      if ( // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type\n      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        continue;\n      }\n      /**\n       * As we go look through the values defined on this type, if we detect\n       * a changed value or a value that was removed in a higher priority, we set\n       * this to true and add this prop to the animation list.\n       */\n\n\n      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      /**\n       * As animations can be set as variant lists, variants or target objects, we\n       * coerce everything to an array if it isn't one already\n       */\n\n      const definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\n       * Build an object of all the resolved values. We'll use this in the subsequent\n       * animateChanges calls to determine whether a value has changed.\n       */\n\n      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\n       * Now we need to loop through all the keys in the prev prop and this prop,\n       * and decide:\n       * 1. If the value has changed, and needs animating\n       * 2. If it has been removed, and needs adding to the removedKeys set\n       * 3. If it has been removed in a higher priority type and needs animating\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n       *    needs adding to the type's protectedKeys list.\n       */\n\n      const {\n        prevResolvedValues = {}\n      } = typeState;\n      const allKeys = { ...prevResolvedValues,\n        ...resolvedValues\n      };\n\n      const markToAnimate = key => {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n\n      for (const key in allKeys) {\n        const next = resolvedValues[key];\n        const prev = prevResolvedValues[key]; // If we've already handled this we can just skip ahead\n\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\n         * If the value has changed, we probably want to animate it.\n         */\n\n        if (next !== prev) {\n          /**\n           * If both values are keyframes, we need to shallow compare them to\n           * detect whether any value has changed. If it has, we animate it.\n           */\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev) || variantDidChange) {\n              markToAnimate(key);\n            } else {\n              /**\n               * If it hasn't changed, we want to ensure it doesn't animate by\n               * adding it to the list of protected keys.\n               */\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== undefined) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\n           * If next hasn't changed and it isn't undefined, we want to check if it's\n           * been removed by a higher priority\n           */\n          markToAnimate(key);\n        } else {\n          /**\n           * If it hasn't changed, we add it to the list of protected values\n           * to ensure it doesn't get animated.\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\n       * Update the typeState so next time animateChanges is called we can compare the\n       * latest prop and resolvedValues to these.\n       */\n\n\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      /**\n       *\n       */\n\n      if (typeState.isActive) {\n        encounteredKeys = { ...encounteredKeys,\n          ...resolvedValues\n        };\n      }\n\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\n       * If this is an inherited prop we want to hard-block animations\n       * TODO: Test as this should probably still handle animations triggered\n       * by removed values?\n       */\n\n\n      if (shouldAnimateType && !isInherited) {\n        animations.push(...definitionList.map(animation => ({\n          animation: animation,\n          options: {\n            type,\n            ...options\n          }\n        })));\n      }\n    }\n    /**\n     * If there are some removed value that haven't been dealt with,\n     * we need to create a new animation that falls back either to the value\n     * defined in the style prop, or the last read value.\n     */\n\n\n    if (removedKeys.size) {\n      const fallbackAnimation = {};\n      removedKeys.forEach(key => {\n        const fallbackTarget = visualElement.getBaseTarget(key);\n\n        if (fallbackTarget !== undefined) {\n          fallbackAnimation[key] = fallbackTarget;\n        }\n      });\n      animations.push({\n        animation: fallbackAnimation\n      });\n    }\n\n    let shouldAnimate = Boolean(animations.length);\n\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\n   * Change whether a certain animation type is active.\n   */\n\n\n  function setActive(type, isActive, options) {\n    var _a; // If the active state hasn't changed, we can safely do nothing here\n\n\n    if (state[type].isActive === isActive) return Promise.resolve(); // Propagate active change to children\n\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(child => {\n      var _a;\n\n      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    const animations = animateChanges(options, type);\n\n    for (const key in state) {\n      state[key].protectedKeys = {};\n    }\n\n    return animations;\n  }\n\n  return {\n    animateChanges,\n    setActive,\n    setAnimateFunction,\n    getState: () => state\n  };\n}\n\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (Array.isArray(next)) {\n    return !shallowCompare(next, prev);\n  }\n\n  return false;\n}\n\nfunction createTypeState() {\n  let isActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return {\n    isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\n\nfunction createState() {\n  return {\n    [AnimationType.Animate]: createTypeState(true),\n    [AnimationType.InView]: createTypeState(),\n    [AnimationType.Hover]: createTypeState(),\n    [AnimationType.Tap]: createTypeState(),\n    [AnimationType.Drag]: createTypeState(),\n    [AnimationType.Focus]: createTypeState(),\n    [AnimationType.Exit]: createTypeState()\n  };\n}\n\nexport { checkVariantsDidChange, createAnimationState, variantPriorityOrder };","map":{"version":3,"sources":["D:/Web Data/Personal-Website/client/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"names":["isAnimationControls","isKeyframesTarget","shallowCompare","animateVisualElement","isVariantLabel","AnimationType","resolveVariant","variantPriorityOrder","Animate","InView","Focus","Hover","Tap","Drag","Exit","reversePriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","animation","options","createAnimationState","animate","state","createState","isInitialRender","buildResolvedTypeValues","acc","definition","resolved","transition","transitionEnd","target","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","_a","props","getProps","context","getVariantContext","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","i","type","typeState","prop","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","definitionList","Array","isArray","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","key","delete","needsAnimating","next","prev","hasOwnProperty","undefined","add","has","blockInitialAnimation","push","size","fallbackAnimation","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","initial","resolve","setActive","variantChildren","child","animationState","getState","createTypeState"],"mappings":"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","sourcesContent":["import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { animateVisualElement } from './animation.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { AnimationType } from './types.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\n\nconst variantPriorityOrder = [\n    AnimationType.Animate,\n    AnimationType.InView,\n    AnimationType.Focus,\n    AnimationType.Hover,\n    AnimationType.Tap,\n    AnimationType.Drag,\n    AnimationType.Exit,\n];\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    const state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (acc, definition) => {\n        const resolved = resolveVariant(visualElement, definition);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(options, changedActiveType) {\n        var _a;\n        const props = visualElement.getProps();\n        const context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                removedKeys.delete(key);\n                typeState.needsAnimating[key] = true;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                if (next !== prev) {\n                    /**\n                     * If both values are keyframes, we need to shallow compare them to\n                     * detect whether any value has changed. If it has, we animate it.\n                     */\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                        if (!shallowCompare(next, prev) || variantDidChange) {\n                            markToAnimate(key);\n                        }\n                        else {\n                            /**\n                             * If it hasn't changed, we want to ensure it doesn't animate by\n                             * adding it to the list of protected keys.\n                             */\n                            typeState.protectedKeys[key] = true;\n                        }\n                    }\n                    else if (next !== undefined) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             * TODO: Test as this should probably still handle animations triggered\n             * by removed values?\n             */\n            if (shouldAnimateType && !isInherited) {\n                animations.push(...definitionList.map((animation) => ({\n                    animation: animation,\n                    options: { type, ...options },\n                })));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                if (fallbackTarget !== undefined) {\n                    fallbackAnimation[key] = fallbackTarget;\n                }\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            props.initial === false &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive, options) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        const animations = animateChanges(options, type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        [AnimationType.Animate]: createTypeState(true),\n        [AnimationType.InView]: createTypeState(),\n        [AnimationType.Hover]: createTypeState(),\n        [AnimationType.Tap]: createTypeState(),\n        [AnimationType.Drag]: createTypeState(),\n        [AnimationType.Focus]: createTypeState(),\n        [AnimationType.Exit]: createTypeState(),\n    };\n}\n\nexport { checkVariantsDidChange, createAnimationState, variantPriorityOrder };\n"]},"metadata":{},"sourceType":"module"}