{"ast":null,"code":"import { invariant } from 'hey-listen';\n\nfunction isCSSVariable(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\n\n\nconst cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nfunction parseCSSVariable(current) {\n  const match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n}\n\nconst maxDepth = 4;\n\nfunction getVariableValue(current, element) {\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n  const [token, fallback] = parseCSSVariable(current); // No CSS variable detected\n\n  if (!token) return; // Attempt to read this CSS variable off the element\n\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\n\n\nfunction resolveCSSVariables(visualElement, _ref, transitionEnd) {\n  let { ...target\n  } = _ref;\n  const element = visualElement.getInstance();\n  if (!(element instanceof Element)) return {\n    target,\n    transitionEnd\n  }; // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n\n  if (transitionEnd) {\n    transitionEnd = { ...transitionEnd\n    };\n  } // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n\n\n  visualElement.forEachValue(value => {\n    const current = value.get();\n    if (!isCSSVariable(current)) return;\n    const resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  }); // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n\n  for (const key in target) {\n    const current = target[key];\n    if (!isCSSVariable(current)) continue;\n    const resolved = getVariableValue(current, element);\n    if (!resolved) continue; // Clone target if it hasn't already been\n\n    target[key] = resolved; // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n\n    if (transitionEnd && transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n\n  return {\n    target,\n    transitionEnd\n  };\n}\n\nexport { cssVariableRegex, parseCSSVariable, resolveCSSVariables };","map":{"version":3,"sources":["D:/Web Data/Personal-Website/client/node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs"],"names":["invariant","isCSSVariable","value","startsWith","cssVariableRegex","parseCSSVariable","current","match","exec","token","fallback","maxDepth","getVariableValue","element","depth","resolved","window","getComputedStyle","getPropertyValue","trim","resolveCSSVariables","visualElement","transitionEnd","target","getInstance","Element","forEachValue","get","set","key","undefined"],"mappings":"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","sourcesContent":["import { invariant } from 'hey-listen';\n\nfunction isCSSVariable(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    const match = cssVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token, fallback] = match;\n    return [token, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    }\n    else if (isCSSVariable(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, { ...target }, transitionEnd) {\n    const element = visualElement.getInstance();\n    if (!(element instanceof Element))\n        return { target, transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = { ...transitionEnd };\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue((value) => {\n        const current = value.get();\n        if (!isCSSVariable(current))\n            return;\n        const resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (const key in target) {\n        const current = target[key];\n        if (!isCSSVariable(current))\n            continue;\n        const resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd && transitionEnd[key] === undefined) {\n            transitionEnd[key] = current;\n        }\n    }\n    return { target, transitionEnd };\n}\n\nexport { cssVariableRegex, parseCSSVariable, resolveCSSVariables };\n"]},"metadata":{},"sourceType":"module"}