{"ast":null,"code":"import _slicedToArray from \"D:/Web Data/Personal-Website/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"D:/Web Data/Personal-Website/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { __rest } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { isString, defaults, isEasingGenerator, defaultOffset, fillOffset, progress } from '@motionone/utils';\nimport { resolveOption } from '../utils/stagger.es.js';\nimport { animateStyle } from '../animate/animate-style.es.js';\nimport { withControls } from '../animate/utils/controls.es.js';\nimport { keyframesList } from '../animate/utils/keyframes.es.js';\nimport { getOptions } from '../animate/utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { isTransform } from '../animate/utils/transforms.es.js';\nimport { calcNextTime } from './utils/calc-time.es.js';\nimport { addKeyframes } from './utils/edit.es.js';\nimport { compareByTime } from './utils/sort.es.js';\n\nfunction timeline(definition) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  var animationDefinitions = createAnimationsFromTimeline(definition, options);\n  /**\n   * Create and start animations\n   */\n\n  var animationFactories = animationDefinitions.map(function (definition) {\n    return animateStyle.apply(void 0, _toConsumableArray(definition));\n  }).filter(Boolean);\n  return withControls(animationFactories, options, // Get the duration from the first animation definition\n  (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\n\nfunction createAnimationsFromTimeline(definition) {\n  var _a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a$defaultOptions = _a.defaultOptions,\n      defaultOptions = _a$defaultOptions === void 0 ? {} : _a$defaultOptions,\n      timelineOptions = __rest(_a, [\"defaultOptions\"]);\n\n  var animationDefinitions = [];\n  var elementSequences = new Map();\n  var elementCache = {};\n  var timeLabels = new Map();\n  var prevTime = 0;\n  var currentTime = 0;\n  var totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the definition array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n\n  for (var i = 0; i < definition.length; i++) {\n    var segment = definition[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n\n    if (isString(segment)) {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n\n    var _segment = _slicedToArray(segment, 3),\n        elementDefinition = _segment[0],\n        keyframes = _segment[1],\n        _segment$ = _segment[2],\n        options = _segment$ === void 0 ? {} : _segment$;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n\n\n    if (options.at !== undefined) {\n      currentTime = calcNextTime(currentTime, options.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n\n\n    var maxDuration = 0;\n    /**\n     * Find all the elements specified in the definition and parse value\n     * keyframes from their timeline definitions.\n     */\n\n    var elements = resolveElements(elementDefinition, elementCache);\n    var numElements = elements.length;\n\n    for (var elementIndex = 0; elementIndex < numElements; elementIndex++) {\n      var element = elements[elementIndex];\n      var elementSequence = getElementSequence(element, elementSequences);\n\n      for (var key in keyframes) {\n        var valueSequence = getValueSequence(key, elementSequence);\n        var valueKeyframes = keyframesList(keyframes[key]);\n        var valueOptions = getOptions(options, key);\n        var _valueOptions$duratio = valueOptions.duration,\n            duration = _valueOptions$duratio === void 0 ? defaultOptions.duration || defaults.duration : _valueOptions$duratio,\n            _valueOptions$easing = valueOptions.easing,\n            easing = _valueOptions$easing === void 0 ? defaultOptions.easing || defaults.easing : _valueOptions$easing;\n\n        if (isEasingGenerator(easing)) {\n          var valueIsTransform = isTransform(key);\n          invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n          var custom = easing.createAnimation(valueKeyframes, // TODO We currently only support explicit keyframes\n          // so this doesn't currently read from the DOM\n          function () {\n            return \"0\";\n          }, valueIsTransform);\n          easing = custom.easing;\n          if (custom.keyframes !== undefined) valueKeyframes = custom.keyframes;\n          if (custom.duration !== undefined) duration = custom.duration;\n        }\n\n        var delay = resolveOption(options.delay, elementIndex, numElements) || 0;\n        var startTime = currentTime + delay;\n        var targetTime = startTime + duration;\n        /**\n         *\n         */\n\n        var _valueOptions$offset = valueOptions.offset,\n            offset = _valueOptions$offset === void 0 ? defaultOffset(valueKeyframes.length) : _valueOptions$offset;\n        /**\n         * If there's only one offset of 0, fill in a second with length 1\n         *\n         * TODO: Ensure there's a test that covers this removal\n         */\n\n        if (offset.length === 1 && offset[0] === 0) {\n          offset[1] = 1;\n        }\n        /**\n         * Fill out if offset if fewer offsets than keyframes\n         */\n\n\n        var remainder = length - valueKeyframes.length;\n        remainder > 0 && fillOffset(offset, remainder);\n        /**\n         * If only one value has been set, ie [1], push a null to the start of\n         * the keyframe array. This will let us mark a keyframe at this point\n         * that will later be hydrated with the previous value.\n         */\n\n        valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n        /**\n         * Add keyframes, mapping offsets to absolute time.\n         */\n\n        addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n        maxDuration = Math.max(delay + duration, maxDuration);\n        totalDuration = Math.max(targetTime, totalDuration);\n      }\n    }\n\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n\n\n  elementSequences.forEach(function (valueSequences, element) {\n    for (var _key in valueSequences) {\n      var _valueSequence = valueSequences[_key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n\n      _valueSequence.sort(compareByTime);\n\n      var _keyframes = [];\n      var valueOffset = [];\n      var valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n\n      for (var _i = 0; _i < _valueSequence.length; _i++) {\n        var _valueSequence$_i = _valueSequence[_i],\n            at = _valueSequence$_i.at,\n            value = _valueSequence$_i.value,\n            _easing = _valueSequence$_i.easing;\n\n        _keyframes.push(value);\n\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(_easing || defaults.easing);\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n\n\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n\n        _keyframes.unshift(_keyframes[0]);\n\n        valueEasing.unshift(\"linear\");\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n\n\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n\n        _keyframes.push(null);\n      }\n\n      animationDefinitions.push([element, _key, _keyframes, Object.assign(Object.assign(Object.assign({}, defaultOptions), {\n        duration: totalDuration,\n        easing: valueEasing,\n        offset: valueOffset\n      }), timelineOptions)]);\n    }\n  });\n  return animationDefinitions;\n}\n\nfunction getElementSequence(element, sequences) {\n  !sequences.has(element) && sequences.set(element, {});\n  return sequences.get(element);\n}\n\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\n\nexport { createAnimationsFromTimeline, timeline };","map":{"version":3,"sources":["D:/Web Data/Personal-Website/client/node_modules/@motionone/dom/dist/timeline/index.es.js"],"names":["__rest","invariant","isString","defaults","isEasingGenerator","defaultOffset","fillOffset","progress","resolveOption","animateStyle","withControls","keyframesList","getOptions","resolveElements","isTransform","calcNextTime","addKeyframes","compareByTime","timeline","definition","options","_a","animationDefinitions","createAnimationsFromTimeline","animationFactories","map","filter","Boolean","duration","defaultOptions","timelineOptions","elementSequences","Map","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","length","segment","set","Array","isArray","name","at","elementDefinition","keyframes","undefined","maxDuration","elements","numElements","elementIndex","element","elementSequence","getElementSequence","key","valueSequence","getValueSequence","valueKeyframes","valueOptions","easing","valueIsTransform","custom","createAnimation","delay","startTime","targetTime","offset","remainder","unshift","Math","max","forEach","valueSequences","sort","valueOffset","valueEasing","value","push","Object","assign","sequences","has","get"],"mappings":"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","sourcesContent":["import { __rest } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { isString, defaults, isEasingGenerator, defaultOffset, fillOffset, progress } from '@motionone/utils';\nimport { resolveOption } from '../utils/stagger.es.js';\nimport { animateStyle } from '../animate/animate-style.es.js';\nimport { withControls } from '../animate/utils/controls.es.js';\nimport { keyframesList } from '../animate/utils/keyframes.es.js';\nimport { getOptions } from '../animate/utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { isTransform } from '../animate/utils/transforms.es.js';\nimport { calcNextTime } from './utils/calc-time.es.js';\nimport { addKeyframes } from './utils/edit.es.js';\nimport { compareByTime } from './utils/sort.es.js';\n\nfunction timeline(definition, options = {}) {\n    var _a;\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\n    /**\n     * Create and start animations\n     */\n    const animationFactories = animationDefinitions\n        .map((definition) => animateStyle(...definition))\n        .filter(Boolean);\n    return withControls(animationFactories, options, \n    // Get the duration from the first animation definition\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition, _a = {}) {\n    var { defaultOptions = {} } = _a, timelineOptions = __rest(_a, [\"defaultOptions\"]);\n    const animationDefinitions = [];\n    const elementSequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the definition array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < definition.length; i++) {\n        const segment = definition[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (isString(segment)) {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        const [elementDefinition, keyframes, options = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (options.at !== undefined) {\n            currentTime = calcNextTime(currentTime, options.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        /**\n         * Find all the elements specified in the definition and parse value\n         * keyframes from their timeline definitions.\n         */\n        const elements = resolveElements(elementDefinition, elementCache);\n        const numElements = elements.length;\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n            const element = elements[elementIndex];\n            const elementSequence = getElementSequence(element, elementSequences);\n            for (const key in keyframes) {\n                const valueSequence = getValueSequence(key, elementSequence);\n                let valueKeyframes = keyframesList(keyframes[key]);\n                const valueOptions = getOptions(options, key);\n                let { duration = defaultOptions.duration || defaults.duration, easing = defaultOptions.easing || defaults.easing, } = valueOptions;\n                if (isEasingGenerator(easing)) {\n                    const valueIsTransform = isTransform(key);\n                    invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n                    const custom = easing.createAnimation(valueKeyframes, \n                    // TODO We currently only support explicit keyframes\n                    // so this doesn't currently read from the DOM\n                    () => \"0\", valueIsTransform);\n                    easing = custom.easing;\n                    if (custom.keyframes !== undefined)\n                        valueKeyframes = custom.keyframes;\n                    if (custom.duration !== undefined)\n                        duration = custom.duration;\n                }\n                const delay = resolveOption(options.delay, elementIndex, numElements) || 0;\n                const startTime = currentTime + delay;\n                const targetTime = startTime + duration;\n                /**\n                 *\n                 */\n                let { offset = defaultOffset(valueKeyframes.length) } = valueOptions;\n                /**\n                 * If there's only one offset of 0, fill in a second with length 1\n                 *\n                 * TODO: Ensure there's a test that covers this removal\n                 */\n                if (offset.length === 1 && offset[0] === 0) {\n                    offset[1] = 1;\n                }\n                /**\n                 * Fill out if offset if fewer offsets than keyframes\n                 */\n                const remainder = length - valueKeyframes.length;\n                remainder > 0 && fillOffset(offset, remainder);\n                /**\n                 * If only one value has been set, ie [1], push a null to the start of\n                 * the keyframe array. This will let us mark a keyframe at this point\n                 * that will later be hydrated with the previous value.\n                 */\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n                /**\n                 * Add keyframes, mapping offsets to absolute time.\n                 */\n                addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n                maxDuration = Math.max(delay + duration, maxDuration);\n                totalDuration = Math.max(targetTime, totalDuration);\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    elementSequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || defaults.easing);\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(\"linear\");\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            animationDefinitions.push([\n                element,\n                key,\n                keyframes,\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\n            ]);\n        }\n    });\n    return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n    !sequences.has(element) && sequences.set(element, {});\n    return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\n\nexport { createAnimationsFromTimeline, timeline };\n"]},"metadata":{},"sourceType":"module"}