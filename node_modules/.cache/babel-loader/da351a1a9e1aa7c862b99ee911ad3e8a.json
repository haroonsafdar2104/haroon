{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Action } from './Action';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\n\nvar AsyncAction = function (_super) {\n  __extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    }\n\n    this.state = state;\n    var id = this.id;\n    var scheduler = this.scheduler;\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.pending = true;\n    this.delay = delay;\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n\n    intervalProvider.clearInterval(id);\n    return undefined;\n  };\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, _delay) {\n    var errored = false;\n    var errorValue;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n\n  AsyncAction.prototype.unsubscribe = function () {\n    if (!this.closed) {\n      var _a = this,\n          id = _a.id,\n          scheduler = _a.scheduler;\n\n      var actions = scheduler.actions;\n      this.work = this.state = this.scheduler = null;\n      this.pending = false;\n      arrRemove(actions, this);\n\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null;\n\n      _super.prototype.unsubscribe.call(this);\n    }\n  };\n\n  return AsyncAction;\n}(Action);\n\nexport { AsyncAction };","map":{"version":3,"mappings":"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","names":["Action","intervalProvider","arrRemove","__extends","scheduler","work","_super","_this","AsyncAction","state","delay","closed","id","recycleAsyncId","pending","requestAsyncId","_id","setInterval","flush","bind","_scheduler","clearInterval","undefined","Error","error","_execute","_delay","errored","errorValue","e","unsubscribe","actions","call"],"sources":["D:\\Web Data\\Personal-Website\\client\\node_modules\\rxjs\\src\\internal\\scheduler\\AsyncAction.ts"],"sourcesContent":["import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: any;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: any, delay: number = 0): any {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id: any, delay: number | null = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    intervalProvider.clearInterval(id);\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}