{"ast":null,"code":"import { visualElement } from '../index.mjs';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\nimport { transformProps } from './utils/transform.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\n\nfunction getComputedStyle(element) {\n  return window.getComputedStyle(element);\n}\n\nconst htmlConfig = {\n  treeType: \"dom\",\n\n  readValueFromInstance(domElement, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle(domElement);\n      const value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  },\n\n  sortNodePosition(a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  },\n\n  getBaseTarget(props, key) {\n    var _a;\n\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  },\n\n  measureViewportBox(element, _ref) {\n    let {\n      transformPagePoint\n    } = _ref;\n    return measureViewportBox(element, transformPagePoint);\n  },\n\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n  resetTransform(element, domElement, props) {\n    const {\n      transformTemplate\n    } = props;\n    domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\"; // Ensure that whatever happens next, we restore our transform on the next frame\n\n    element.scheduleRender();\n  },\n\n  restoreTransform(instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n\n  removeValueFromRenderState(key, _ref2) {\n    let {\n      vars,\n      style\n    } = _ref2;\n    delete vars[key];\n    delete style[key];\n  },\n\n  /**\n   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n   * can be animated by Motion.\n   */\n  makeTargetAnimatable(element, _ref3, _ref4) {\n    let {\n      transition,\n      transitionEnd,\n      ...target\n    } = _ref3;\n    let {\n      transformValues\n    } = _ref4;\n    let isMounted = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let origin = getOrigin(target, transition || {}, element);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      const parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n\n    return {\n      transition,\n      transitionEnd,\n      ...target\n    };\n  },\n\n  scrapeMotionValuesFromProps,\n\n  build(element, renderState, latestValues, options, props) {\n    if (element.isVisible !== undefined) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  },\n\n  render: renderHTML\n};\nconst htmlVisualElement = visualElement(htmlConfig);\nexport { getComputedStyle, htmlConfig, htmlVisualElement };","map":{"version":3,"sources":["D:/Web Data/Personal-Website/client/node_modules/framer-motion/dist/es/render/html/visual-element.mjs"],"names":["visualElement","getOrigin","checkTargetForNewValues","buildHTMLStyles","isCSSVariable","parseDomVariant","transformProps","scrapeMotionValuesFromProps","renderHTML","getDefaultValueType","measureViewportBox","getComputedStyle","element","window","htmlConfig","treeType","readValueFromInstance","domElement","key","has","defaultType","default","computedStyle","value","getPropertyValue","trim","sortNodePosition","a","b","compareDocumentPosition","getBaseTarget","props","_a","style","transformPagePoint","resetTransform","transformTemplate","transform","scheduleRender","restoreTransform","instance","mutableState","removeValueFromRenderState","vars","makeTargetAnimatable","transition","transitionEnd","target","transformValues","isMounted","origin","parsed","build","renderState","latestValues","options","isVisible","undefined","visibility","render","htmlVisualElement"],"mappings":"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","sourcesContent":["import { visualElement } from '../index.mjs';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\nimport { transformProps } from './utils/transform.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\n\nfunction getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nconst htmlConfig = {\n    treeType: \"dom\",\n    readValueFromInstance(domElement, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            const computedStyle = getComputedStyle(domElement);\n            const value = (isCSSVariable(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    },\n    sortNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget(props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox(element, { transformPagePoint }) {\n        return measureViewportBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */\n    resetTransform(element, domElement, props) {\n        const { transformTemplate } = props;\n        domElement.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform(instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */\n    makeTargetAnimatable(element, { transition, transitionEnd, ...target }, { transformValues }, isMounted = true) {\n        let origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            const parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return {\n            transition,\n            transitionEnd,\n            ...target,\n        };\n    },\n    scrapeMotionValuesFromProps,\n    build(element, renderState, latestValues, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible\n                ? \"visible\"\n                : \"hidden\";\n        }\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n    },\n    render: renderHTML,\n};\nconst htmlVisualElement = visualElement(htmlConfig);\n\nexport { getComputedStyle, htmlConfig, htmlVisualElement };\n"]},"metadata":{},"sourceType":"module"}