{"ast":null,"code":"import _toConsumableArray from \"D:/Web Data/Personal-Website/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { invariant } from 'hey-listen';\nimport { stopAnimation, animateVisualElement } from '../render/utils/animation.mjs';\nimport { setValues } from '../render/utils/setters.mjs';\n/**\n * @public\n */\n\nfunction animationControls() {\n  /**\n   * Track whether the host component has mounted.\n   */\n  var hasMounted = false;\n  /**\n   * Pending animations that are started before a component is mounted.\n   * TODO: Remove this as animations should only run in effects\n   */\n\n  var pendingAnimations = [];\n  /**\n   * A collection of linked component animation controls.\n   */\n\n  var subscribers = new Set();\n  var controls = {\n    subscribe: function subscribe(visualElement) {\n      subscribers.add(visualElement);\n      return function () {\n        return void subscribers.delete(visualElement);\n      };\n    },\n    start: function start(definition, transitionOverride) {\n      /**\n       * TODO: We only perform this hasMounted check because in Framer we used to\n       * encourage the ability to start an animation within the render phase. This\n       * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n       * we can ditch this.\n       */\n      if (hasMounted) {\n        var animations = [];\n        subscribers.forEach(function (visualElement) {\n          animations.push(animateVisualElement(visualElement, definition, {\n            transitionOverride: transitionOverride\n          }));\n        });\n        return Promise.all(animations);\n      } else {\n        return new Promise(function (resolve) {\n          pendingAnimations.push({\n            animation: [definition, transitionOverride],\n            resolve: resolve\n          });\n        });\n      }\n    },\n    set: function set(definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(function (visualElement) {\n        setValues(visualElement, definition);\n      });\n    },\n    stop: function stop() {\n      subscribers.forEach(function (visualElement) {\n        stopAnimation(visualElement);\n      });\n    },\n    mount: function mount() {\n      hasMounted = true;\n      pendingAnimations.forEach(function (_ref) {\n        var animation = _ref.animation,\n            resolve = _ref.resolve;\n        controls.start.apply(controls, _toConsumableArray(animation)).then(resolve);\n      });\n      return function () {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\n\nexport { animationControls };","map":{"version":3,"sources":["D:/Web Data/Personal-Website/client/node_modules/framer-motion/dist/es/animation/animation-controls.mjs"],"names":["invariant","stopAnimation","animateVisualElement","setValues","animationControls","hasMounted","pendingAnimations","subscribers","Set","controls","subscribe","visualElement","add","delete","start","definition","transitionOverride","animations","forEach","push","Promise","all","resolve","animation","set","stop","mount","then"],"mappings":";AAAA,SAASA,SAAT,QAA0B,YAA1B;AACA,SAASC,aAAT,EAAwBC,oBAAxB,QAAoD,+BAApD;AACA,SAASC,SAAT,QAA0B,6BAA1B;AAEA;AACA;AACA;;AACA,SAASC,iBAAT,GAA6B;AACzB;AACJ;AACA;AACI,MAAIC,UAAU,GAAG,KAAjB;AACA;AACJ;AACA;AACA;;AACI,MAAMC,iBAAiB,GAAG,EAA1B;AACA;AACJ;AACA;;AACI,MAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;AACA,MAAMC,QAAQ,GAAG;AACbC,IAAAA,SADa,qBACHC,aADG,EACY;AACrBJ,MAAAA,WAAW,CAACK,GAAZ,CAAgBD,aAAhB;AACA,aAAO;AAAA,eAAM,KAAKJ,WAAW,CAACM,MAAZ,CAAmBF,aAAnB,CAAX;AAAA,OAAP;AACH,KAJY;AAKbG,IAAAA,KALa,iBAKPC,UALO,EAKKC,kBALL,EAKyB;AAClC;AACZ;AACA;AACA;AACA;AACA;AACY,UAAIX,UAAJ,EAAgB;AACZ,YAAMY,UAAU,GAAG,EAAnB;AACAV,QAAAA,WAAW,CAACW,OAAZ,CAAoB,UAACP,aAAD,EAAmB;AACnCM,UAAAA,UAAU,CAACE,IAAX,CAAgBjB,oBAAoB,CAACS,aAAD,EAAgBI,UAAhB,EAA4B;AAC5DC,YAAAA,kBAAkB,EAAlBA;AAD4D,WAA5B,CAApC;AAGH,SAJD;AAKA,eAAOI,OAAO,CAACC,GAAR,CAAYJ,UAAZ,CAAP;AACH,OARD,MASK;AACD,eAAO,IAAIG,OAAJ,CAAY,UAACE,OAAD,EAAa;AAC5BhB,UAAAA,iBAAiB,CAACa,IAAlB,CAAuB;AACnBI,YAAAA,SAAS,EAAE,CAACR,UAAD,EAAaC,kBAAb,CADQ;AAEnBM,YAAAA,OAAO,EAAPA;AAFmB,WAAvB;AAIH,SALM,CAAP;AAMH;AACJ,KA7BY;AA8BbE,IAAAA,GA9Ba,eA8BTT,UA9BS,EA8BG;AACZf,MAAAA,SAAS,CAACK,UAAD,EAAa,+GAAb,CAAT;AACA,aAAOE,WAAW,CAACW,OAAZ,CAAoB,UAACP,aAAD,EAAmB;AAC1CR,QAAAA,SAAS,CAACQ,aAAD,EAAgBI,UAAhB,CAAT;AACH,OAFM,CAAP;AAGH,KAnCY;AAoCbU,IAAAA,IApCa,kBAoCN;AACHlB,MAAAA,WAAW,CAACW,OAAZ,CAAoB,UAACP,aAAD,EAAmB;AACnCV,QAAAA,aAAa,CAACU,aAAD,CAAb;AACH,OAFD;AAGH,KAxCY;AAyCbe,IAAAA,KAzCa,mBAyCL;AACJrB,MAAAA,UAAU,GAAG,IAAb;AACAC,MAAAA,iBAAiB,CAACY,OAAlB,CAA0B,gBAA4B;AAAA,YAAzBK,SAAyB,QAAzBA,SAAyB;AAAA,YAAdD,OAAc,QAAdA,OAAc;AAClDb,QAAAA,QAAQ,CAACK,KAAT,OAAAL,QAAQ,qBAAUc,SAAV,EAAR,CAA6BI,IAA7B,CAAkCL,OAAlC;AACH,OAFD;AAGA,aAAO,YAAM;AACTjB,QAAAA,UAAU,GAAG,KAAb;AACAI,QAAAA,QAAQ,CAACgB,IAAT;AACH,OAHD;AAIH;AAlDY,GAAjB;AAoDA,SAAOhB,QAAP;AACH;;AAED,SAASL,iBAAT","sourcesContent":["import { invariant } from 'hey-listen';\nimport { stopAnimation, animateVisualElement } from '../render/utils/animation.mjs';\nimport { setValues } from '../render/utils/setters.mjs';\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */\n    const pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set();\n    const controls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement);\n            return () => void subscribers.delete(visualElement);\n        },\n        start(definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */\n            if (hasMounted) {\n                const animations = [];\n                subscribers.forEach((visualElement) => {\n                    animations.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride,\n                    }));\n                });\n                return Promise.all(animations);\n            }\n            else {\n                return new Promise((resolve) => {\n                    pendingAnimations.push({\n                        animation: [definition, transitionOverride],\n                        resolve,\n                    });\n                });\n            }\n        },\n        set(definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition);\n            });\n        },\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement);\n            });\n        },\n        mount() {\n            hasMounted = true;\n            pendingAnimations.forEach(({ animation, resolve }) => {\n                controls.start(...animation).then(resolve);\n            });\n            return () => {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls };\n"]},"metadata":{},"sourceType":"module"}