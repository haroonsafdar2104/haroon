{"ast":null,"code":"import _toConsumableArray from \"D:/Web Data/Personal-Website/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"D:/Web Data/Personal-Website/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"D:/Web Data/Personal-Website/client/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"],\n    _excluded2 = [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"];\nimport { inertia, animate } from 'popmotion';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isEasingArray, easingDefinitionToFunction } from './easing.mjs';\nimport { isAnimatable } from './is-animatable.mjs';\nimport { getDefaultTransition } from './default-transitions.mjs';\nimport { warning } from 'hey-listen';\nimport { getAnimatableNone } from '../../render/dom/value-types/animatable-none.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\n\nfunction isTransitionDefined(_ref) {\n  var when = _ref.when,\n      delay = _ref.delay,\n      delayChildren = _ref.delayChildren,\n      staggerChildren = _ref.staggerChildren,\n      staggerDirection = _ref.staggerDirection,\n      repeat = _ref.repeat,\n      repeatType = _ref.repeatType,\n      repeatDelay = _ref.repeatDelay,\n      from = _ref.from,\n      transition = _objectWithoutProperties(_ref, _excluded);\n\n  return !!Object.keys(transition).length;\n}\n\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\n\nfunction convertTransitionToAnimationOptions(_ref2) {\n  var ease = _ref2.ease,\n      times = _ref2.times,\n      yoyo = _ref2.yoyo,\n      flip = _ref2.flip,\n      loop = _ref2.loop,\n      transition = _objectWithoutProperties(_ref2, _excluded2);\n\n  var options = _objectSpread({}, transition);\n\n  if (times) options[\"offset\"] = times;\n  /**\n   * Convert any existing durations from seconds to milliseconds\n   */\n\n  if (transition.duration) options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay) options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  /**\n   * Map easing names to Popmotion's easing functions\n   */\n\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  /**\n   * Support legacy transition API\n   */\n\n\n  if (transition.type === \"tween\") options.type = \"keyframes\";\n  /**\n   * TODO: These options are officially removed from the API.\n   */\n\n  if (yoyo || loop || flip) {\n    warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  /**\n   * TODO: Popmotion 9 has the ability to automatically detect whether to use\n   * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n   * It'd be good to introduce a similar thing here.\n   */\n\n\n  if (transition.type !== \"spring\") options.type = \"keyframes\";\n  return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\n\n\nfunction getDelayFromTransition(transition, key) {\n  var _a, _b;\n\n  var valueTransition = getValueTransition(transition, key) || {};\n  return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\n\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = _toConsumableArray(options.to);\n    options.to[0] = options.from;\n  }\n\n  return options;\n}\n\nfunction getPopmotionAnimationOptions(transition, options, key) {\n  if (Array.isArray(options.to) && transition.duration === undefined) {\n    transition.duration = 0.8;\n  }\n\n  hydrateKeyframes(options);\n  /**\n   * Get a default transition if none is determined to be defined.\n   */\n\n  if (!isTransitionDefined(transition)) {\n    transition = _objectSpread(_objectSpread({}, transition), getDefaultTransition(key, options.to));\n  }\n\n  return _objectSpread(_objectSpread({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\n\n\nfunction getAnimation(key, value, target, transition, onComplete) {\n  var valueTransition = getValueTransition(transition, key) || {};\n  var origin = valueTransition.from !== undefined ? valueTransition.from : value.get();\n  var isTargetAnimatable = isAnimatable(key, target);\n\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    /**\n     * If we're trying to animate from \"none\", try and get an animatable version\n     * of the target. This could be improved to work both ways.\n     */\n    origin = getAnimatableNone(key, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n\n  var isOriginAnimatable = isAnimatable(key, origin);\n  warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \".concat(key, \" from \\\"\").concat(origin, \"\\\" to \\\"\").concat(target, \"\\\". \").concat(origin, \" is not an animatable value - to enable this animation set \").concat(origin, \" to a value animatable to \").concat(target, \" via the `style` property.\"));\n\n  function start() {\n    var options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete: onComplete,\n      onUpdate: function onUpdate(v) {\n        return value.set(v);\n      }\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? inertia(_objectSpread(_objectSpread({}, options), valueTransition)) : animate(_objectSpread(_objectSpread({}, getPopmotionAnimationOptions(valueTransition, options, key)), {}, {\n      onUpdate: function onUpdate(v) {\n        options.onUpdate(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: function onComplete() {\n        options.onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    }));\n  }\n\n  function set() {\n    var finalTarget = resolveFinalValueInKeyframes(target);\n    value.set(finalTarget);\n    onComplete();\n    valueTransition.onUpdate && valueTransition.onUpdate(finalTarget);\n    valueTransition.onComplete && valueTransition.onComplete();\n    return {\n      stop: function stop() {}\n    };\n  }\n\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\n\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\n\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone(\"\", potentialUnitType);\n}\n\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n */\n\n\nfunction startAnimation(key, value, target) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (instantAnimationState.current) {\n    transition = {\n      type: false\n    };\n  }\n\n  return value.start(function (onComplete) {\n    var delayTimer;\n    var controls;\n    var animation = getAnimation(key, value, target, transition, onComplete);\n    var delay = getDelayFromTransition(transition, key);\n\n    var start = function start() {\n      return controls = animation();\n    };\n\n    if (delay) {\n      delayTimer = window.setTimeout(start, secondsToMilliseconds(delay));\n    } else {\n      start();\n    }\n\n    return function () {\n      clearTimeout(delayTimer);\n      controls && controls.stop();\n    };\n  });\n}\n\nexport { convertTransitionToAnimationOptions, getDelayFromTransition, getPopmotionAnimationOptions, getValueTransition, getZeroUnit, hydrateKeyframes, isTransitionDefined, isZero, startAnimation };","map":{"version":3,"sources":["D:/Web Data/Personal-Website/client/node_modules/framer-motion/dist/es/animation/utils/transitions.mjs"],"names":["inertia","animate","secondsToMilliseconds","isEasingArray","easingDefinitionToFunction","isAnimatable","getDefaultTransition","warning","getAnimatableNone","instantAnimationState","resolveFinalValueInKeyframes","isTransitionDefined","when","delay","delayChildren","staggerChildren","staggerDirection","repeat","repeatType","repeatDelay","from","transition","Object","keys","length","legacyRepeatWarning","convertTransitionToAnimationOptions","ease","times","yoyo","flip","loop","options","duration","map","type","getDelayFromTransition","key","_a","_b","valueTransition","getValueTransition","hydrateKeyframes","Array","isArray","to","getPopmotionAnimationOptions","undefined","getAnimation","value","target","onComplete","origin","get","isTargetAnimatable","isZero","getZeroUnit","isOriginAnimatable","start","velocity","getVelocity","onUpdate","v","set","finalTarget","stop","parseFloat","indexOf","potentialUnitType","startAnimation","current","delayTimer","controls","animation","window","setTimeout","clearTimeout"],"mappings":"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","sourcesContent":["import { inertia, animate } from 'popmotion';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isEasingArray, easingDefinitionToFunction } from './easing.mjs';\nimport { isAnimatable } from './is-animatable.mjs';\nimport { getDefaultTransition } from './default-transitions.mjs';\nimport { warning } from 'hey-listen';\nimport { getAnimatableNone } from '../../render/dom/value-types/animatable-none.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, ...transition }) {\n    return !!Object.keys(transition).length;\n}\nlet legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\nfunction convertTransitionToAnimationOptions({ ease, times, yoyo, flip, loop, ...transition }) {\n    const options = { ...transition };\n    if (times)\n        options[\"offset\"] = times;\n    /**\n     * Convert any existing durations from seconds to milliseconds\n     */\n    if (transition.duration)\n        options[\"duration\"] = secondsToMilliseconds(transition.duration);\n    if (transition.repeatDelay)\n        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n    /**\n     * Map easing names to Popmotion's easing functions\n     */\n    if (ease) {\n        options[\"ease\"] = isEasingArray(ease)\n            ? ease.map(easingDefinitionToFunction)\n            : easingDefinitionToFunction(ease);\n    }\n    /**\n     * Support legacy transition API\n     */\n    if (transition.type === \"tween\")\n        options.type = \"keyframes\";\n    /**\n     * TODO: These options are officially removed from the API.\n     */\n    if (yoyo || loop || flip) {\n        warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n        legacyRepeatWarning = true;\n        if (yoyo) {\n            options.repeatType = \"reverse\";\n        }\n        else if (loop) {\n            options.repeatType = \"loop\";\n        }\n        else if (flip) {\n            options.repeatType = \"mirror\";\n        }\n        options.repeat = loop || yoyo || flip || transition.repeat;\n    }\n    /**\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n     * It'd be good to introduce a similar thing here.\n     */\n    if (transition.type !== \"spring\")\n        options.type = \"keyframes\";\n    return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\nfunction getDelayFromTransition(transition, key) {\n    var _a, _b;\n    const valueTransition = getValueTransition(transition, key) || {};\n    return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n    if (Array.isArray(options.to) && options.to[0] === null) {\n        options.to = [...options.to];\n        options.to[0] = options.from;\n    }\n    return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n    if (Array.isArray(options.to) && transition.duration === undefined) {\n        transition.duration = 0.8;\n    }\n    hydrateKeyframes(options);\n    /**\n     * Get a default transition if none is determined to be defined.\n     */\n    if (!isTransitionDefined(transition)) {\n        transition = {\n            ...transition,\n            ...getDefaultTransition(key, options.to),\n        };\n    }\n    return {\n        ...options,\n        ...convertTransitionToAnimationOptions(transition),\n    };\n}\n/**\n *\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n    const valueTransition = getValueTransition(transition, key) || {};\n    let origin = valueTransition.from !== undefined ? valueTransition.from : value.get();\n    const isTargetAnimatable = isAnimatable(key, target);\n    if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n        /**\n         * If we're trying to animate from \"none\", try and get an animatable version\n         * of the target. This could be improved to work both ways.\n         */\n        origin = getAnimatableNone(key, target);\n    }\n    else if (isZero(origin) && typeof target === \"string\") {\n        origin = getZeroUnit(target);\n    }\n    else if (!Array.isArray(target) &&\n        isZero(target) &&\n        typeof origin === \"string\") {\n        target = getZeroUnit(origin);\n    }\n    const isOriginAnimatable = isAnimatable(key, origin);\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${key} from \"${origin}\" to \"${target}\". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \\`style\\` property.`);\n    function start() {\n        const options = {\n            from: origin,\n            to: target,\n            velocity: value.getVelocity(),\n            onComplete,\n            onUpdate: (v) => value.set(v),\n        };\n        return valueTransition.type === \"inertia\" ||\n            valueTransition.type === \"decay\"\n            ? inertia({ ...options, ...valueTransition })\n            : animate({\n                ...getPopmotionAnimationOptions(valueTransition, options, key),\n                onUpdate: (v) => {\n                    options.onUpdate(v);\n                    valueTransition.onUpdate && valueTransition.onUpdate(v);\n                },\n                onComplete: () => {\n                    options.onComplete();\n                    valueTransition.onComplete && valueTransition.onComplete();\n                },\n            });\n    }\n    function set() {\n        const finalTarget = resolveFinalValueInKeyframes(target);\n        value.set(finalTarget);\n        onComplete();\n        valueTransition.onUpdate && valueTransition.onUpdate(finalTarget);\n        valueTransition.onComplete && valueTransition.onComplete();\n        return { stop: () => { } };\n    }\n    return !isOriginAnimatable ||\n        !isTargetAnimatable ||\n        valueTransition.type === false\n        ? set\n        : start;\n}\nfunction isZero(value) {\n    return (value === 0 ||\n        (typeof value === \"string\" &&\n            parseFloat(value) === 0 &&\n            value.indexOf(\" \") === -1));\n}\nfunction getZeroUnit(potentialUnitType) {\n    return typeof potentialUnitType === \"number\"\n        ? 0\n        : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n */\nfunction startAnimation(key, value, target, transition = {}) {\n    if (instantAnimationState.current) {\n        transition = { type: false };\n    }\n    return value.start((onComplete) => {\n        let delayTimer;\n        let controls;\n        const animation = getAnimation(key, value, target, transition, onComplete);\n        const delay = getDelayFromTransition(transition, key);\n        const start = () => (controls = animation());\n        if (delay) {\n            delayTimer = window.setTimeout(start, secondsToMilliseconds(delay));\n        }\n        else {\n            start();\n        }\n        return () => {\n            clearTimeout(delayTimer);\n            controls && controls.stop();\n        };\n    });\n}\n\nexport { convertTransitionToAnimationOptions, getDelayFromTransition, getPopmotionAnimationOptions, getValueTransition, getZeroUnit, hydrateKeyframes, isTransitionDefined, isZero, startAnimation };\n"]},"metadata":{},"sourceType":"module"}