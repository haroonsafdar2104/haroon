{"ast":null,"code":"import sync from 'framesync';\nimport React__default, { useContext } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\n\nclass MeasureLayoutWithContext extends React__default.Component {\n  /**\n   * This only mounts projection nodes for components that\n   * need measuring, we might want to do it for all components\n   * in order to incorporate transforms\n   */\n  componentDidMount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup,\n      layoutId\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    addScaleCorrector(defaultScaleCorrectors);\n\n    if (projection) {\n      if (layoutGroup.group) layoutGroup.group.add(projection);\n\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n\n      projection.root.didUpdate();\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions({ ...projection.options,\n        onExitComplete: () => this.safeToRemove()\n      });\n    }\n\n    globalProjectionState.hasEverUpdated = true;\n  }\n\n  getSnapshotBeforeUpdate(prevProps) {\n    const {\n      layoutDependency,\n      visualElement,\n      drag,\n      isPresent\n    } = this.props;\n    const projection = visualElement.projection;\n    if (!projection) return null;\n    /**\n     * TODO: We use this data in relegate to determine whether to\n     * promote a previous element. There's no guarantee its presence data\n     * will have updated by this point - if a bug like this arises it will\n     * have to be that we markForRelegation and then find a new lead some other way,\n     * perhaps in didUpdate\n     */\n\n    projection.isPresent = isPresent;\n\n    if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        /**\n         * If there's another stack member taking over from this one,\n         * it's in charge of the exit animation and therefore should\n         * be in charge of the safe to remove. Otherwise we call it here.\n         */\n        sync.postRender(() => {\n          var _a;\n\n          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n\n    return null;\n  }\n\n  componentDidUpdate() {\n    const {\n      projection\n    } = this.props.visualElement;\n\n    if (projection) {\n      projection.root.didUpdate();\n\n      if (!projection.currentAnimation && projection.isLead()) {\n        this.safeToRemove();\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup: promoteContext\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.remove(projection);\n      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister) promoteContext.deregister(projection);\n    }\n  }\n\n  safeToRemove() {\n    const {\n      safeToRemove\n    } = this.props;\n    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n  }\n\n  render() {\n    return null;\n  }\n\n}\n\nfunction MeasureLayout(props) {\n  const [isPresent, safeToRemove] = usePresence();\n  const layoutGroup = useContext(LayoutGroupContext);\n  return React__default.createElement(MeasureLayoutWithContext, { ...props,\n    layoutGroup: layoutGroup,\n    switchLayoutGroup: useContext(SwitchLayoutGroupContext),\n    isPresent: isPresent,\n    safeToRemove: safeToRemove\n  });\n}\n\nconst defaultScaleCorrectors = {\n  borderRadius: { ...correctBorderRadius,\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  },\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\nexport { MeasureLayout };","map":{"version":3,"sources":["D:/Web Data/Personal-Website/client/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs"],"names":["sync","React__default","useContext","usePresence","LayoutGroupContext","SwitchLayoutGroupContext","globalProjectionState","correctBorderRadius","correctBoxShadow","addScaleCorrector","MeasureLayoutWithContext","Component","componentDidMount","visualElement","layoutGroup","switchLayoutGroup","layoutId","props","projection","defaultScaleCorrectors","group","add","register","root","didUpdate","addEventListener","safeToRemove","setOptions","options","onExitComplete","hasEverUpdated","getSnapshotBeforeUpdate","prevProps","layoutDependency","drag","isPresent","undefined","willUpdate","promote","relegate","postRender","_a","getStack","members","length","componentDidUpdate","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","remove","deregister","render","MeasureLayout","createElement","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow"],"mappings":"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","sourcesContent":["import sync from 'framesync';\nimport React__default, { useContext } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\n\nclass MeasureLayoutWithContext extends React__default.Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener(\"animationComplete\", () => {\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const projection = visualElement.projection;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                sync.postRender(() => {\n                    var _a;\n                    if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            if (!projection.currentAnimation && projection.isLead()) {\n                this.safeToRemove();\n            }\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\n        const { projection } = visualElement;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = useContext(LayoutGroupContext);\n    return (React__default.createElement(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\n}\nconst defaultScaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\nexport { MeasureLayout };\n"]},"metadata":{},"sourceType":"module"}