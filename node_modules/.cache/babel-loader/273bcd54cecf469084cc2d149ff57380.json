{"ast":null,"code":"import { useEffect, useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { usePresence } from '../../components/AnimatePresence/use-presence.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { createAnimationState } from '../../render/utils/animation-state.mjs';\nimport { AnimationType } from '../../render/utils/types.mjs';\nimport { makeRenderlessComponent } from '../utils/make-renderless-component.mjs';\nconst animations = {\n  animation: makeRenderlessComponent(_ref => {\n    let {\n      visualElement,\n      animate\n    } = _ref;\n\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n\n    if (isAnimationControls(animate)) {\n      useEffect(() => animate.subscribe(visualElement), [animate]);\n    }\n  }),\n  exit: makeRenderlessComponent(props => {\n    const {\n      custom,\n      visualElement\n    } = props;\n    const [isPresent, safeToRemove] = usePresence();\n    const presenceContext = useContext(PresenceContext);\n    useEffect(() => {\n      visualElement.isPresent = isPresent;\n      const animation = visualElement.animationState && visualElement.animationState.setActive(AnimationType.Exit, !isPresent, {\n        custom: presenceContext && presenceContext.custom || custom\n      });\n\n      if (animation && !isPresent) {\n        animation.then(safeToRemove);\n      }\n    }, [isPresent]);\n  })\n};\nexport { animations };","map":{"version":3,"sources":["D:/Web Data/Personal-Website/client/node_modules/framer-motion/dist/es/motion/features/animations.mjs"],"names":["useEffect","useContext","isAnimationControls","usePresence","PresenceContext","createAnimationState","AnimationType","makeRenderlessComponent","animations","animation","visualElement","animate","animationState","subscribe","exit","props","custom","isPresent","safeToRemove","presenceContext","setActive","Exit","then"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,UAApB,QAAsC,OAAtC;AACA,SAASC,mBAAT,QAAoC,iDAApC;AACA,SAASC,WAAT,QAA4B,mDAA5B;AACA,SAASC,eAAT,QAAgC,mCAAhC;AACA,SAASC,oBAAT,QAAqC,wCAArC;AACA,SAASC,aAAT,QAA8B,8BAA9B;AACA,SAASC,uBAAT,QAAwC,wCAAxC;AAEA,MAAMC,UAAU,GAAG;AACfC,EAAAA,SAAS,EAAEF,uBAAuB,CAAC,QAAgC;AAAA,QAA/B;AAAEG,MAAAA,aAAF;AAAiBC,MAAAA;AAAjB,KAA+B;;AAC/D;AACR;AACA;AACA;AACA;AACQD,IAAAA,aAAa,CAACE,cAAd,KAAiCF,aAAa,CAACE,cAAd,GAA+BP,oBAAoB,CAACK,aAAD,CAApF;AACA;AACR;AACA;;AACQ,QAAIR,mBAAmB,CAACS,OAAD,CAAvB,EAAkC;AAC9BX,MAAAA,SAAS,CAAC,MAAMW,OAAO,CAACE,SAAR,CAAkBH,aAAlB,CAAP,EAAyC,CAACC,OAAD,CAAzC,CAAT;AACH;AACJ,GAbiC,CADnB;AAefG,EAAAA,IAAI,EAAEP,uBAAuB,CAAEQ,KAAD,IAAW;AACrC,UAAM;AAAEC,MAAAA,MAAF;AAAUN,MAAAA;AAAV,QAA4BK,KAAlC;AACA,UAAM,CAACE,SAAD,EAAYC,YAAZ,IAA4Bf,WAAW,EAA7C;AACA,UAAMgB,eAAe,GAAGlB,UAAU,CAACG,eAAD,CAAlC;AACAJ,IAAAA,SAAS,CAAC,MAAM;AACZU,MAAAA,aAAa,CAACO,SAAd,GAA0BA,SAA1B;AACA,YAAMR,SAAS,GAAGC,aAAa,CAACE,cAAd,IACdF,aAAa,CAACE,cAAd,CAA6BQ,SAA7B,CAAuCd,aAAa,CAACe,IAArD,EAA2D,CAACJ,SAA5D,EAAuE;AACnED,QAAAA,MAAM,EAAGG,eAAe,IAAIA,eAAe,CAACH,MAApC,IACJA;AAF+D,OAAvE,CADJ;;AAKA,UAAIP,SAAS,IAAI,CAACQ,SAAlB,EAA6B;AACzBR,QAAAA,SAAS,CAACa,IAAV,CAAeJ,YAAf;AACH;AACJ,KAVQ,EAUN,CAACD,SAAD,CAVM,CAAT;AAWH,GAf4B;AAfd,CAAnB;AAiCA,SAAST,UAAT","sourcesContent":["import { useEffect, useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { usePresence } from '../../components/AnimatePresence/use-presence.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { createAnimationState } from '../../render/utils/animation-state.mjs';\nimport { AnimationType } from '../../render/utils/types.mjs';\nimport { makeRenderlessComponent } from '../utils/make-renderless-component.mjs';\n\nconst animations = {\n    animation: makeRenderlessComponent(({ visualElement, animate }) => {\n        /**\n         * We dynamically generate the AnimationState manager as it contains a reference\n         * to the underlying animation library. We only want to load that if we load this,\n         * so people can optionally code split it out using the `m` component.\n         */\n        visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n        /**\n         * Subscribe any provided AnimationControls to the component's VisualElement\n         */\n        if (isAnimationControls(animate)) {\n            useEffect(() => animate.subscribe(visualElement), [animate]);\n        }\n    }),\n    exit: makeRenderlessComponent((props) => {\n        const { custom, visualElement } = props;\n        const [isPresent, safeToRemove] = usePresence();\n        const presenceContext = useContext(PresenceContext);\n        useEffect(() => {\n            visualElement.isPresent = isPresent;\n            const animation = visualElement.animationState &&\n                visualElement.animationState.setActive(AnimationType.Exit, !isPresent, {\n                    custom: (presenceContext && presenceContext.custom) ||\n                        custom,\n                });\n            if (animation && !isPresent) {\n                animation.then(safeToRemove);\n            }\n        }, [isPresent]);\n    }),\n};\n\nexport { animations };\n"]},"metadata":{},"sourceType":"module"}